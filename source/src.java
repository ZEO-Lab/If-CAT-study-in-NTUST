/* autogenerated by Processing revision 1293 on 2024-07-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.AWTException;
import java.awt.Robot;
import java.awt.event.KeyEvent;
import java.util.*;
import gifAnimation.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class src extends PApplet {

// Depth sorting example by Jakub Valtar
// https://github.com/JakubValtar






private String page_name = "選擇貓咪";
private String student_cat = "pipi";
private String filePath = "pic/character/enemy/paper.png";
private int page_state = 2;
private int keybits = 0;
private int level = 1;

private int MoveingLeft, MoveingRight;
private int MoveingTop, MoveingDown;
private int Shooting, LaserShoot;
private int CallMenu;

private HashMap<String, page> hm = new HashMap<String, page>();
private Robot robot;
public Gif warning;

private ChooseCat cat;
private MainPage m1;
private ChoosePage cp1;
private College_Freshman cf1;
private College_Sophomore cs1;
private College_Junior cj1;
private College_Senior cs2;
private College_Graduate  research;

public void setup() {
  /* size commented out by preprocessor */;
  surface.setTitle("If 貓咪 study in NTUST");
  try {
    robot = new Robot();
  }
  catch(AWTException e) {
  }

  cat = new ChooseCat();
  m1 = new MainPage(student_cat);
  cp1 = new ChoosePage(student_cat, level);
  cf1 = new College_Freshman(student_cat);
  cs1 = new College_Sophomore(student_cat);
  cj1 = new College_Junior(student_cat);
  cs2 = new College_Senior(student_cat);
  research = new College_Graduate(student_cat);

  hm.put("選擇貓咪", cat);
  hm.put("主畫面", m1);
  hm.put("選擇學期", cp1);
  hm.put("大一", cf1);
  hm.put("大二", cs1);
  hm.put("大三", cj1);
  hm.put("大四", cs2);
  hm.put("研究所", research);
  shift();

  warning = new Gif (this, "pic/warning.gif");
  warning.play();
}
public void draw() {
  // println("page_state:",page_state);
  // println("next_exe_state:",next_exe_state);
  keybits = (1<<7) | (CallMenu << 6) | (LaserShoot << 5) | (Shooting << 4) | (MoveingDown << 3) | (MoveingTop << 2) | (MoveingRight << 1) | MoveingLeft;
  switch(page_state) {
  case 0:
    if (!mousePressed) {
      reset(page_name, hm.get(page_name));
      page_state = 1;
    }
    break;
  case 1:
    hm.get(page_name).render();
    page_state = (hm.get(page_name).cut.startCutscene()) ? 2 : 1;
    break;
  case 2:
    hm.get(page_name).render();
    switch(page_name) {
    case "選擇貓咪":
      if (cat.getCat() != "wait") {
        student_cat = cat.getCat();
        // page_name = "主畫面";
      }
      break;
    case "主畫面":
      if (hm.get(page_name).theChoseButton() == "退出") {
        exit();
      }
    case "選擇關卡":
      break;
    default :
      hm.get(page_name).move(keybits);
      if (hm.get(page_name).getlevelPass()) {
        level = hm.get(page_name).getLevel() + 1;
      }
      break;
    }
    page_state = (hm.get(page_name).isComplete()) ? 3 : 2;
    break;
  case 3:
    page_state = (hm.get(page_name).cut.endCutscene()) ? 4 : 3;
    break;
  case 4:
    page_state = (hm.get(page_name).cut.runCutscene()) ? 5 : 4;
    break;
  case 5:
    page_name =  hm.get(page_name).theChoseButton();
    page_state = 0;
    break;
  }
}

public void reset(String page_str, page obj) {
  hm.remove(page_str);
  switch(page_str) {
  case"主畫面" :
    obj = new MainPage(student_cat);
    break;
  case"選擇關卡":
    obj = new ChoosePage(student_cat, level);
    break;
  case"大一" :
    obj = new College_Freshman(student_cat);
    break;
  case"大二" :
    obj = new College_Sophomore(student_cat);
    break;
  case"大三" :
    obj = new College_Junior(student_cat);
    break;
  case "大四":
    obj = new College_Senior(student_cat);
    break;
  case "研究所" :
    obj = new College_Graduate(student_cat);
    break;
  }
  hm.put(page_str, obj);
}

public void shift() {
  robot.keyPress(KeyEvent.VK_SHIFT);
  robot.keyRelease(KeyEvent.VK_SHIFT);
}
public void mousePressed() {
  if (mouseButton ==  LEFT) {
    Shooting = 1;
  }
  if (mouseButton ==  RIGHT) {
    LaserShoot = 1;
  }
}
public void mouseReleased() {
  if (mouseButton ==  LEFT) {
    Shooting = 0;
  }
  if (mouseButton ==  RIGHT) {
    LaserShoot = 0;
  }
}
public void keyPressed() {
  if (key == 'a') {
    MoveingLeft = 1;
  }
  if (key == 'd') {
    MoveingRight = 1;
  }
  if (key == 'w') {
    MoveingTop = 1;
  }
  if (key == 's') {
    MoveingDown = 1;
  }
  if (key == ESC) {
    key = 0;
    CallMenu = 1;
  }
}

public void keyReleased() {
  if (key == 'a') {
    MoveingLeft = 0;
  }
  if (key == 'd') {
    MoveingRight = 0;
  }
  if (key == 'w') {
    MoveingTop = 0;
  }
  if (key == 's') {
    MoveingDown = 0;
  }
  if (key == ESC) {
    key = 0;
    CallMenu = 0;
  }
}

public class RectObject {
  public float x, y;
  public float w, h;
  public RectObject(float _xpos, float _ypos, float _width, float _height) {
    x = _xpos;
    y = _ypos;
    w = _width;
    h = _height;
  }
}
class Boss extends Character{
    public float move_angle = 0;
    public float bullet_time_1 = 0;
    public float bullet_level1_count = 0;
    public float bullet_level1_time = 0;
    public float bullet_level1_cd = 500;
    public int bullet_level1_damage = 10;
    
    public float bullet_cd = 1500;
    
    public PImage boss = loadImage("pic/character/enemy/exam.png");
    public Boss_HP boss_hp = new  Boss_HP();
    
    Boss(GameMap gmap,int life_value) {
        super(new RectObject(gmap.getWidth() / 2 , gmap.getHeigh() / 2 , 200 , 200) , life_value);
        setMovingSpeed(1);
    }
    public void render(GameMap gmap) {
        imageMode(CENTER);
        gmap.drawImage(boss ,x ,y, w, h);
        boss_hp.render();
    }
    public void move(Player player) {
        move_angle =rotation(player.getX(),player.getY()); 
        x += cos(move_angle) * getMovingSpeed();
        y += sin(move_angle) * getMovingSpeed();
    }
    
    public void shooting(GameMap gmap ,Player player) {
        level_1(player,3);
        bullet_shootCharater(player , bullet_level1_damage);
        bullet_program(gmap);
    }
    
    public void level_1(Player player,int counts) {
        if (millis() > bullet_time_1 + bullet_cd && distance<600) {
            if (bullet_level1_count < counts) {
                if (millis() > bullet_level1_time + bullet_level1_cd) {
                    angle = rotation(player.getX() , player.getY());
                    for (float i = 0;i < 10;i++) {
                        bulletlist.add(new Bullet(new RectObject(x,y,30,30) , angle , color(0,255,0)));
                        angle += 2 * PI / 10;
                    }
                    for (Bullet bullet : bulletlist) {
                        bullet.setSpeed(20);
                    }
                    bullet_level1_count ++;
                    bullet_level1_time =  millis();
                }
            }
            else{
                bullet_time_1 = millis();
            }
        }
        else{
            bullet_level1_count = 0; 
        }
    }
    
    public void set_level1_Bullet_damage(int level1) {
        bullet_level1_damage = level1;
    }
    private class Boss_HP extends HP{
        Boss_HP() {
            super(hp.getLifeValue());
        }
        public void render() {
            float current_life = (width - 200) * hp.getLifeValue() / hp.getOriginalLifeValue();
            rectMode(CORNER);
            stroke(0);
            strokeWeight(5);
            fill(255);
            rect(100,height - 100,(width - 200),30,3);
            fill(200,0,0);
            rect(100,height - 100,current_life,30,3);
        }
    }
}

public class Boss_double extends Boss{
    private float bullet_time_2 = 0;
    private float bullet_level2_count = 0;
    private float bullet_level2_time = 0;
    private float bullet_level2_cd = 500;
    public int bullet_level2_damage = 20;
    
    ArrayList<Bullet> bulletlist2 = new ArrayList<Bullet>();
    public Boss_double(GameMap gmap,int life_value) {
        super(gmap,life_value);
    }
    
    public void shooting(GameMap gmap ,Player player) {
        level_1(player,3);
        bullet_shootCharater(player , bullet_level1_damage);
        if (hp.getLifePercentage() < 0.5f) {
            level_2(player);
            bullet2_shootCharater(player , bullet_level2_damage);
        }
        bullet_program(gmap);
        bullet2_program(gmap);
    }
    
    public void level_2(Player player) {
        if (millis() > bullet_time_2 + bullet_cd && distance<600) {
            if (bullet_level2_count < 5) {
                if (millis() > bullet_level2_time + bullet_level2_cd) {
                    angle = rotation(player.getX() , player.getY());
                    float dx = 50 * cos(PI / 2 - angle);
                    float dy = 50 * sin(PI / 2 - angle);
                    bulletlist2.add(new Bullet(new RectObject(x,y,30,30) , angle , color(255,255,0)));
                    bulletlist2.add(new Bullet(new RectObject(x + dx,y - dy,30,30) , angle , color(255,255,0)));
                    bulletlist2.add(new Bullet(new RectObject(x - dx,y + dy,30,30) , angle , color(255,255,0)));
                    bullet_level2_count ++;
                    bullet_level2_time =  millis();
                }
            }
            else{
                bullet_time_2 = millis();
            }
        }
        else{
            bullet_level2_count = 0; 
        }
    }
    public void bullet2_program(GameMap gmap) {
        for (Bullet bullet2 : bulletlist2) {
            bullet2.move(); 
            bullet2.OutOfRange(gmap); 
            bullet2.render(gmap); 
        }
        bullet_Remove(bulletlist2);
    }
    public void bullet2_shootCharater(Character c1,float bullet_damage) {
        for (Bullet bullet2 : bulletlist2) {
            float radians =  distance(c1.getX(),c1.getY(),bullet2.getX(),bullet2.getY());
            if (radians < (c1.getWidth() / 2)) {
                c1.isHurt(bullet_damage);
                bullet2.isDistroy = true;
            } 
        }
        bullet_Remove(bulletlist2);
    }
    public void set_level2_Bullet_damage(int level2) {
        bullet_level2_damage = level2;
    }
}

public class Boss_Project extends Boss_double {
    private int laser_state = 0;
    private boolean delay_mode = false;
    private boolean laser_mode = false;
    
    private int smoke_time;
    private int smoke_cd = 3000;
    
    private float laser_time = 0;
    private float laser_duration = 3000;
    private float laser_cd = 2000;
    
    PImage boos_level2 = loadImage("pic/character/enemy/boss_project2.png");
    private Project_Laser laser = new Project_Laser();
    private  Delay_Smoke delay_smoke = new Delay_Smoke();
    
    public Boss_Project(GameMap gmap,int life_value) {
        super(gmap,life_value);
        boss = loadImage("pic/character/enemy/boss_project.png");
    }
    public void render(GameMap gmap) {
        imageMode(CENTER);
        gmap.drawImage(((hp.getLifePercentage() < 0.5f) ? boos_level2 : boss) ,x ,y, w, h);
        boss_hp.render();
        if (hp.getLifePercentage() < 0.7f) {
            delay_mode = true;
        }
        if (hp.getLifePercentage() < 0.5f) {
            laser_mode = true;
        }
    }
    
    public void shooting(GameMap gmap ,Player player) {
        level_2(player);
        bullet2_program(gmap);
        bullet2_shootCharater(player , bullet_level2_damage);
        
        if (delay_mode) {
            delay_smoke.render(gmap);
            delay_smoke.affectPlayer(player);
            if (millis() > smoke_time + smoke_cd) {
                smoke_time = millis();
                delay_smoke.generation(new RectObject(x,y,700,0));
            }
        }
        if (laser_mode) {
            switch(laser_state) {
                case 0 :
                    if (millis() > laser_time + laser_cd) {
                        laser_time = millis();
                        laser_state = 1;
                        laser.reset();	
                    }
                    break;
                case 1:
                    laser.render(x,y,gmap,player);
                    laser_shootCharater(player,20);
                    laser_state = (millis() > laser_time + laser_duration) ? 2 : 1;
                    break;	
                case 2 :
                    laser_time = millis();
                    laser_state = 0;
                    break;	
            }
        }
    }
    
    public void laser_shootCharater(Player player,float laser_damage) {
        float dis = distance(player.getX() , player.getY() , x  ,y);
        float player_angle = rotation(player.getX() , player.getY());
        float vertical_line = dis * sin(laser.getAngle() - player_angle);
        if (laser.isShooting() && dis < 350 && abs(laser.getAngle() - player_angle) < 1 && vertical_line<player.getWidth() / 2) {
            player.isHurt(laser_damage);
        }
    }
    private class Delay_Smoke{
        private float x,y,rad;
        ArrayList<RectObject> smokelist = new ArrayList<RectObject>();
        
        public void generation(RectObject object) {
            x = object.x;
            y = object.y;
            rad = object.w / 2;
            for (float i =-  PI;i <=  PI;i += (2 * PI / 6)) {
                float _x = x + rad * cos(i);
                float _y = y + rad * sin(i);
                smokelist.add(new RectObject(_x,_y,millis() + 2000,0));
            }
        }
        public void render(GameMap gmap) {
            fill(200,50,50,100);
            for (RectObject smoke : smokelist) {
                gmap.fillellipse(smoke.x,smoke.y,100,100);
            }
            removeSmoke();
        }
        public void affectPlayer(Player player) {
            for (RectObject smoke : smokelist) {
                float dis = player.distance(player.getX(),player.getY() , smoke.x , smoke.y);
                float range = (50 + player.getWidth() * 0.5f);
                if (dis <= range && smoke.h ==  0) {
                    player.setAffect(0,millis() + 500);
                    smoke.h = 1;
                }
                if (dis > range) {
                    smoke.h = 0;
                }
            }
        }
        public void removeSmoke() {
            for (int i = smokelist.size() - 1; i>= 0; i -= 1) {
                RectObject smoke = smokelist.get(0);           
                if (smoke.w < millis()) {
                    smokelist.remove(smoke);
                }
            }
        }
    }
    private class Project_Laser{
        private int circle_width = 0;
        private int laser_beam_width = 50;
        private int laser_beam_length = 300;
        
        private int laser_state = 0;
        private float laser_angle = 0;
        private boolean Shooting = false;
        
        public void render(float x,float y,GameMap gmap,Player player) {
            rectMode(CORNER);
            noStroke();
            fill(0,255,0);
            pushMatrix();
            gmap.translation(x,y);
            switch(laser_state) {
                case 0:
                    Shooting = false;
                    fill(0,255,0);
                    if (circle_width % 5 > 0) {
                        fill(255,255,255);
                    }
                    circle_width += 3;
                    laser_angle = atan2(player.getY() - y, player.getX() - x);
                    rotate(laser_angle);
                    strokeWeight(2);
                    stroke(0);
                    ellipse(60,0,circle_width,circle_width);
                    laser_state = (circle_width>= 50) ? 1 : 0;
                    break;
                case 1:
                    Shooting = true;
                    rotate(laser_angle);
                    ellipse(60,0,circle_width * 0.5f,circle_width);
                    rect(60, -laser_beam_width / 2,laser_beam_length,laser_beam_width);
                    fill(255);
                    float ratio = random(0.6f, 0.8f);
                    ellipse(60,0,circle_width * 0.5f * ratio,circle_width * ratio);
                    rect(60, -(laser_beam_width * ratio) / 2,laser_beam_length,laser_beam_width * ratio);
                    break;
            }
            popMatrix();
        }
        public void reset() {
            laser_state = 0;
            circle_width = 0;
        }
        public float getAngle() {
            return laser_angle;
        }
        public boolean isShooting() {
            return Shooting;
        }
    }
}

public class Reearch_Institution extends Boss{
    public int state = 0;
    
    private float laser_time = 0;
    private float laser_duration = 3000;
    private float laser_cd = 5000;
    
    public Shell shell = new Shell(new RectObject(x,y,w,h),300);
    public Shell shell2 = new Shell(new RectObject(x,y,w,h),500);
    private Explosion bomb = new Explosion();
    Reearch_Institution(GameMap gmap,int life_value) {
        super(gmap,life_value);
        bullet_level1_cd = 100;
        boss = loadImage("pic/character/enemy/research_institution.png");
    }
    public void render(GameMap gmap) {
        imageMode(CENTER);
        gmap.drawImage(boss ,x ,y, w, h);
        boss_hp.render();
        switch(state) {
            case 0 :
                state = (hp.getLifePercentage() < 0.6f) ? 1 : 0;
                break;	
            case 1 :
                if (!shell.hp.isGone()) {
                    shell.update(x,y);
                    shell.render(gmap);
                }
                state = (hp.getLifePercentage() < 0.3f) ? 2 : 1;
                break;	
            case 2 :
                if (!shell2.hp.isGone()) {
                    shell2.update(x,y);
                    shell2.render(gmap);
                }
                bomb.render(gmap);
                break;	
        }
    }
    public void shooting(GameMap gmap ,Player player) {
        level_1(player,10);
        bullet_program(gmap);
        bullet_shootCharater(player , 10);
        
        if (state ==  2) {
            if (millis() > laser_time + laser_cd) {
                laser_time = millis();
                bomb.reset();
                bomb.generation(new RectObject(x,y,500,0));
            }
            laser_shootCharater(player,20);
        }
    }
    public void laser_shootCharater(Player player,float laser_damage) {
        if (bomb.hitPlayer(player)) {
            player.isHurt(laser_damage);
        }
    }
    public void isHurt(float value) {
        switch(state) {
            case 1 :
                if (!shell.hp.isGone()) {
                    shell.isHurt(value);      
                }
                else{
                    hp.damage(value);
                }
                break;	
            case 2 :
                if (!shell2.hp.isGone()) {
                    shell2.isHurt(value);      
                }
                else{
                    hp.damage(value);
                }
                break;	
            default :
                hp.damage(value);
                break;
        }
    }
    public void level_1(Player player,int counts) {
        if (millis() > bullet_time_1 + bullet_cd && distance<600) {
            if (bullet_level1_count < counts) {
                if (millis() > bullet_level1_time + bullet_level1_cd) {
                    bulletlist.add(new Bullet(new RectObject(x,y,30,30) , angle , color(0,255,0)));
                    angle += 2 * PI / 10;
                    bullet_level1_count ++;
                    bullet_level1_time =  millis();
                }
                for (Bullet bullet : bulletlist) {
                    bullet.setSpeed(20);
                }
            }
            else{
                bullet_time_1 = millis();
                angle = rotation(player.getX() , player.getY());
            }
        }
        else{
            bullet_level1_count = 0; 
        }
    }
    private class Shell extends Character{
        int red_color = 0;
        private Shell_HP shell_hp;
        Shell(RectObject object,float life_value) {
            super(object,life_value);
            shell_hp = new Shell_HP(life_value);
        }
        public void render(GameMap gmap) {
            stroke(red_color,0,255 - red_color);
            strokeWeight(10);
            noFill();
            gmap.fillellipse(x,y,w + 20,h + 20);
            shell_hp.render();
        }
        public void update(float xp , float yp) {
            x = xp;
            y = yp;
            red_color = (red_color<= 0) ? 0 : red_color - 5;
        }
        public void isHurt(float value) {
            hp.damage(value);
            red_color = 255;
        }
        private class Shell_HP extends HP{
            Shell_HP(float life_value) {
                super(life_value);
            }
            public void render() {
                float current_life = (width - 200) * hp.getLifeValue() / hp.getOriginalLifeValue();
                rectMode(CENTER);
                stroke(0);
                strokeWeight(5);
                fill(0,200);
                rect(width / 2,height - 100 + 15,(width - 200),30,3);
                fill(0,0,200);
                rect(width / 2,height - 100 + 15,current_life,30,3);
            }
        }
    }
    private class Explosion {
        
        private float x ,y ,rad;
        private int state = 0;
        private boolean Shooting = false;
        
        private int circle_width = 0;
        private int laser_beam_width = 50;
        private int laser_beam_length = 300;
        
        ArrayList<RectObject> bomblist = new ArrayList<RectObject>();
        
        public void generation(RectObject object) {
            x = object.x;
            y = object.y;
            rad = object.w / 2;
            for (float i =-  PI;i <=  PI;i += (2 * PI / 6)) {
                float _x = x + rad * cos(i);
                float _y = y + rad * sin(i);
                bomblist.add(new RectObject(_x,_y,millis() + 3000,0));
            }
        }
        public void render(GameMap gmap) {
            strokeWeight(1);
            switch(state) {
                case 0:
                    Shooting = false;
                    fill(0,0,255);
                    if (circle_width % 5 > 0) {
                        fill(255,255,255);
                    }
                    circle_width += 3;
                    for (RectObject bomb : bomblist) {
                        gmap.fillellipse(bomb.x,bomb.y,circle_width,circle_width);
                    }
                    state = (circle_width>= 100) ? 1 : 0;
                    break;
                case 1:
                    Shooting = true;
                    for (RectObject bomb : bomblist) {
                        strokeWeight(1);
                        fill(0,0,255);
                        rectMode(CORNER);
                        gmap.fillellipse(bomb.x,bomb.y,circle_width,circle_width);
                        gmap.fillrect(bomb.x - laser_beam_width / 2 , bomb.y - laser_beam_length , laser_beam_width , laser_beam_length);
                        noStroke();
                        fill(255);
                        float ratio = random(0.6f, 0.8f);
                        gmap.fillellipse(bomb.x,bomb.y,circle_width * ratio,circle_width * ratio);
                        gmap.fillrect(bomb.x - laser_beam_width / 2 * ratio , bomb.y - laser_beam_length , laser_beam_width * ratio , laser_beam_length);
                    }
                    break;
            }            
            removeObject();
        }
        public void removeObject() {
            for (int i = bomblist.size() - 1; i>= 0; i -= 1) {
                RectObject bomb = bomblist.get(i);            
                if (bomb.w < millis()) {
                    bomblist.remove(bomb);
                }
            }
        }
        public boolean hitPlayer(Player player) {
            for (RectObject bomb : bomblist) {
                if (player.getY() < bomb.y && player.getY() > bomb.y - laser_beam_length && abs(player.getX() - bomb.x) < laser_beam_width / 2 && Shooting) {
                    return true;
                }
            }
            return false;
        }
        public void reset() {
            state = 0;
            circle_width = 0;
        }
        public boolean isShooting() {
            return Shooting;
        }
    }
}

public class Professor extends Reearch_Institution {
    private int fire_size = 0;
    private int fire_range = 600;
    private float fire_angle = -PI;
    private PImage  ring_of_fire = loadImage("pic/character/enemy/Ring_of_flame.png");
    public Professor(GameMap gmap,int life_value) {
        super(gmap ,life_value);
        boss = loadImage("pic/character/enemy/ntust.png");
    }
    public void render(GameMap gmap) {
        imageMode(CENTER);
        gmap.drawImage(boss ,x ,y, w, h);
        boss_hp.render();
        // println(state);
        switch(state) {
            case 0 :
                if (!shell.hp.isGone()) {
                    shell.update(x,y);
                    shell.render(gmap);
                }
                state = (hp.getLifePercentage() < 0.6f) ? 1 : 0;
                break;	
            case 1 :
                imageMode(CENTER);
                gmap.drawImage(ring_of_fire, x, y, fire_size, fire_size);
                fire_size +=5;
                state = (fire_size >= fire_range) ? 2 : 1;
                break;
            case 2:
                imageMode(CENTER);
                pushMatrix();
                gmap.translation(x  ,y);
                rotate(fire_angle);
                image(ring_of_fire, 0, 0, fire_size, fire_size);
                popMatrix();
                gmap.drawImage(boss ,x ,y, w, h);
                fire_angle = (fire_angle>= PI) ? - PI : fire_angle + (2 * PI / 10);
                state = (hp.getLifePercentage() < 0.3f) ? 3 : 2;
                break;
            case 3 :
                if (!shell2.hp.isGone()) {
                    shell2.update(x,y);
                    shell2.render(gmap);
                }
                break;	
        }
    }
    
    public void shooting(GameMap gmap ,Player player) {
        level_1(player,((state == 3) ? 30 : 20));
        bullet_program(gmap);
        bullet_shootCharater(player , 10);
        if (state == 2) {
            if (player.distance(x,y,player.getX(),player.getY()) <= fire_range / 2) {
                player.isHurt(10);
            }
        }
    }
    public void isHurt(float value) {
        switch(state) {
            case 0 :
                if (!shell.hp.isGone()) {
                    shell.isHurt(value);      
                }
                else{
                    hp.damage(value);
                }
                break;	
            case 2:
                hp.damage(value);
                break;
            case 3 :
                if (!shell2.hp.isGone()) {
                    shell2.isHurt(value);      
                }
                else{
                    hp.damage(value);
                }
                break;	
        }
    }
    
}   
class Button{
    private PVector Pos = new PVector(0,0);
    private PImage pressedImg = loadImage("pic/button/Pressed.png");
    private PImage  hoverImg = loadImage("pic/button/Hover.png");
    private PFont myFont;
    
    private float w = 0.0f , h = 0.0f;
    private float LeftSide ,RightSide , TopSide , BottomSide;
    private String str;
    private String content;
    private float strSizes;
    
    private boolean Pressed = false;
    private boolean Enable = true;
    
    Button(int x,int y,int _w,int _h,String str) {
        Pos.x = x;
        Pos.y = y;
        w = _w;
        h = _h;
        this.str = str;
        content = str;
        strSizes = h - 30;
        LeftSide = Pos.x - w / 2;
        RightSide = Pos.x + w / 2;
        TopSide = Pos.y - h / 2;
        BottomSide = Pos.y + h / 2;
    }
    public void setContent(String content) {
        this.content = content;
    }
    public void setImage(String hoverimgPath , String pressedimgPath) {
        hoverImg = loadImage(hoverimgPath);
        pressedImg = loadImage(pressedimgPath);
    }
    public void render() {
        update();
        myFont = createFont("標楷體",strSizes);/* 直接輸入字型名稱，只要電腦有安裝該自行即可顯示 */
        textFont(myFont);
        imageMode(CENTER);
        if (Enable) {
            image( (Pressed) ? pressedImg : hoverImg,Pos.x,Pos.y,w,h);
        }
        else{ 
            image(pressedImg,Pos.x,Pos.y,w,h);
        }
        fill(0); 
        // textSize(strSizes);
        textAlign(CENTER,CENTER);
        text(str,Pos.x ,Pos.y);
    }
    public void update() {
        if (Enable) {
            Pressed = (mousePressed && mouseButton == LEFT 
            && mouseX >= LeftSide && mouseX <= RightSide && mouseY >= TopSide && mouseY <= BottomSide) ? 
            true : false;  
        }
            else{
            Pressed = false;
        }   
    }
    public void setEnable(boolean state) {
        Enable = state;
    }
    public boolean isPressed() {
        return Pressed;
    }
    public String getbuttonString() {
        return str;
    }
    public String getbuttonContent() {
        return content;
    }
        
}
        
abstract class Character{
    public float bullet_damage = 10;
    private boolean characterComplete = false;
    private int second;
    private String crack_state = "initialize";
    
    private float _x,_y;//default x, y for shaking
    public float x,y,w,h;
    public float distance,angle;    
    public boolean isShake;
    
    public HP hp;
    public PVector moving = new PVector(10 , 1);
    public ArrayList<Bullet> bulletlist  = new ArrayList<Bullet>();
    private confetti[] cc = new confetti[10];
    Character() {
        hp =  new HP(200);
    }
    Character(float life) {
        x = 0;
        y = 0;
        w = 10;
        h = 10;
        hp = new HP(life);
    }
    Character(RectObject object,float life) {
        x = object.x;
        y = object.y;
        w = object.w;
        h = object.h;
        _x = x;
        _y = y;
        hp = new HP(life);
    }
    public float getX() {return x;}
    public float getY() {return y;}
    public float getWidth() {return w;}
    public float getHeigh() {return h;}
    public void setShaking(boolean state) {
        isShake = state;
    }
    
    public abstract void render(GameMap gmap);
    public void shooting() {}; 
    public void isHurt(float value) {
        hp.damage(value);
    }
    public void setMovingSpeed(int speed) {
        moving.x = speed;
    }
    public float getMovingSpeed() {
        return  moving.x * moving.y;
    }
    public void bullet_program(GameMap gmap) {
        for (Bullet bb : bulletlist) {
            bb.move(); 
            bb.OutOfRange(gmap); 
            bb.render(gmap); 
        }
        bullet_Remove(bulletlist);
    }
    public void bullet_shootCharater(Character c1,float bullet_damage) {
        for (Bullet bb : bulletlist) {
            float radians =  distance(c1.getX(),c1.getY(),bb.getX(),bb.getY());
            if (radians < (c1.getWidth() / 2)) {
                c1.isHurt(bullet_damage);
                bb.isDistroy = true;
            } 
        }
        bullet_Remove(bulletlist);
    }
    public void bullet_Remove(ArrayList<Bullet> _bulletlist) {
        for (int i = _bulletlist.size() - 1; i>= 0; i -= 1) {
            Bullet bb = _bulletlist.get(i);  
            if (bb.isDistroy ==  true) {
                _bulletlist.remove(bb);
            }
        }
    }
    public boolean crack(GameMap gmap) {
        int counter = 0;
        switch(crack_state) {
            case "initialize" :
                _x = x;
                _y = y; 
                for (int i = 0; i < cc.length; i++) {
                    cc[i] = new confetti(gmap.getWindowX(x),gmap.getWindowY(y));
                }
                second = millis();
                crack_state = (isShake) ? "shack" : "crack";
                break;	
            case "shack":
                x = random(_x - 2,_x + 2);
                y = random(_y - 2,_y + 2);
                render(gmap);
                crack_state = (millis()>= second + 1000) ? "crack" : "shack";
                break;
            case "crack":
                for (confetti c : cc) {
                    c.show();
                    counter = (c.outOfRange()) ? counter + 1 : counter;
                }
                return counter ==  10;
        }
        return false;
    }
    public float distance(float e_x,float e_y,float c_x,float c_y) {
        return sqrt(pow((e_x - c_x),2) + pow((e_y - c_y),2));
    }
    public float rotation(float targetX,float targetY) {
        return atan2(targetY - y, targetX - x);  
    }
    public void setComplete(boolean state) {
        characterComplete = state;
    }
    public boolean isComplete() {
        return characterComplete;
    }
}
class Bullet{
    private float x,y;
    private float w,h;
    private float angle;
    private int bullet_speed = 15; 
    private int bullet_moving_time = 0; 
    private int bullet_color = color(255,255,10); 
    
    boolean isDistroy = false;
    
    private PImage bullet_Image;
    
    Bullet(RectObject object,float rotation,String imgPath) {
        x = object.x;
        y = object.y;
        w = object.w;
        h = object.h;
        angle = rotation;
        bullet_Image = loadImage(imgPath);
        bullet_moving_time = millis();
    }
    Bullet(RectObject object,float rotation,int bullet_color) {
        x = object.x;
        y = object.y;
        w = object.w;
        h = object.h;
        angle = rotation;
        this.bullet_color = bullet_color;
        bullet_moving_time = millis();
    }
    public void setSpeed(int speed) {
        bullet_speed = speed;
    }
    public void setImage(String imgPath) {
        bullet_Image = loadImage(imgPath);
    }
    public float getX() {return x;}
    public float getY() {return y;}
    public float getWidth() {return w;}
    public float getHeigh() {return h;}
    public void render(GameMap gmap) {
        if (bullet_Image == null) {
            stroke(0);
            strokeWeight(1);
            fill(bullet_color);
            gmap.fillellipse(x , y , w , h);
        }
        else{
            imageMode(CENTER);
            gmap.drawImage(bullet_Image,x,y,w,h);      
        }
    }
    
    public void move() {
        x += cos(angle) * bullet_speed;
        y += sin(angle) * bullet_speed;  
    }
    public boolean OutOfRange(GameMap gmap) {
        int times = millis() - bullet_moving_time;
        // if (y < gmap.getY() || y > gmap.getHeigh() || x < gmap.getX() || x > gmap.getWidth() || times > 2000) {
        if (times > 1500) {
            isDistroy = true;
        }
        return isDistroy;
    }
}
public class HP{
    private float original_life_value;
    private float life_value;
    HP(float life_value) {
        original_life_value = life_value;
        this.life_value = life_value;
        }
    public void render(float x,float y) {
        float current_life = 40 * life_value / original_life_value;
        rectMode(CENTER);
        stroke(0);
        strokeWeight(1);
        fill(255);
        rect(x ,y,40,15);
        rectMode(CORNER);
        fill(color(227,23,13));
        rect(x - 20  , y - 7.5f , current_life ,15);
        }
    public void heal(float value) {
        life_value = ((life_value + value)>original_life_value) ? original_life_value : life_value + value;
        }
    public void damage(float attack_value) { 
        life_value = ((life_value - attack_value)<0) ? 0 : life_value - attack_value;
        }
    public boolean isGone() {return(life_value <=  0);} 
    public float getLifePercentage() {return life_value / original_life_value;}
    public float getLifeValue() {return life_value;}
    public float getOriginalLifeValue() {return original_life_value;}
    }

private class confetti{
    private float x,y;
    private float xspeed,yspeed;
    confetti(float _x, float _y) {
        x = _x;
        y = _y;
        burst();
        }
    public void  burst() { 
        xspeed = random( -10,10);
        yspeed = random( -10,10);
        }
    public void update() {
        x += xspeed;
        y += yspeed;
        yspeed += 1;
        }
    public void show() {
        fill(0);
        if (!outOfRange()) {
            update();
            circle(x,y,10);
            }
        }
    public boolean outOfRange() {
        boolean out = ((x<= -10) || (x>= width + 10) || (y<= -10) || (y>= height + 10)) ? true : false;
        return out;
        }
    }
public class ChooseCat extends page {
    String[] button_str = {"牛奶" ,"皮皮" , "小咪"};
    String[] cat_str = {"milk" ,"pipi" , "mi"};
    String choose_cat = "wait";

    Button[] button = new Button[3];
    PFont myFont;
    PImage backgroundImage ;
    PImage milk=loadImage("pic/Character/milk/right.png");
    PImage pipi=loadImage("pic/Character/pipi/right.png");
    PImage mi=loadImage("pic/Character/mi/right.png");

    public ChooseCat () {
        super("選擇貓咪","creater");
        backgroundImage = loadImage("pic/ntust.jpg");
        for(int i=0;i<button.length;i++){
            button[i] = new Button(width/4*(i+1) , height/2+200 , 200,70 , button_str[i] );
            button[i].setContent(cat_str[i]);
        }
    }
    public void render(){
        imageMode(CORNER);
        image(backgroundImage , 0 , 0,width,height);
        title(width / 2,height / 2 - 200);
        rectMode(CENTER);
        fill(255,150);
        rect(width/2 , height/2+50 , 800 ,400,20);
        option();
    }
    public void title(int x,int y) {
        textAlign(CENTER);
        myFont = createFont("標楷體",80);/* 直接輸入字型名稱，只要電腦有安裝該自行即可顯示 */
        textFont(myFont);
        fill(0);
        text("選擇就學的貓咪",x-2,y-2);  
        text("選擇就學的貓咪",x+2,y-2);  
        text("選擇就學的貓咪",x-2,y+2);  
        text("選擇就學的貓咪",x+2,y+2);  
        fill(255);
        text("選擇就學的貓咪",x,y);  
    }
    public void option(){
        imageMode(CENTER);
        image(milk , width/4 ,  height/2 , 250, 200);
        image(pipi , width/4*2 ,  height/2 , 200, 200);
        image(mi , width/4*3 ,  height/2 , 250, 200);
        Arrays.stream(button).forEach(bb -> bb.render());
        for(int i=0;i<button.length;i++){
            if(button[i].isPressed()){
                choose_cat=button[i].getbuttonContent();
                chosebut = "主畫面";
                PageComplete = true;
                break;
            }
        }
    }
    
    public String getCat(){
        return choose_cat;
    } 
}
class ChoosePage extends page{
    private int bwidth = 300;
    private int bheigh = bwidth / 16 * 5;
    private String butt_str[] = {"大一" ,"大二","大三","大肆","研究所"};
    private final String rebutt_hovered_imgPath = "pic/button/Return_Hovered.png";
    private final String rebutt_pressed_imgPath = "pic/button/Return_Pressed.png";
    
    private PFont myFont;
    private PImage backgroundImage;
    private Button[] button = new Button[5];
    private Button return_button;
    
    ChoosePage(String catname,int level) {
        super("選擇學期",catname);
        backgroundImage = loadImage("pic/page/"+catname+"/choose.jpg");
        button[0] = new Button(width / 6 , 500,bwidth,bheigh,butt_str[0]);
        button[1] = new Button(width / 6 * 2 , 600,bwidth,bheigh,butt_str[1]);
        button[2] = new Button(width / 6 * 3 , 500,bwidth,bheigh,butt_str[2]);
        button[3] = new Button(width / 6 * 4 , 600,bwidth,bheigh,butt_str[3]);
        button[4] = new Button(width / 6 * 5 , 500,bwidth,bheigh,butt_str[4]);
        for(int i=0;i<button.length ;i++){
            if((level-1)<i){
                button[i].setEnable(false);
            }
        }
        return_button = new Button(70,70,100,100," ");
        return_button.setImage(rebutt_hovered_imgPath,rebutt_pressed_imgPath);
    }
    public void render() {
        imageMode(CORNER);
        image(backgroundImage , 0 , 0,width,height);
        title(width / 2 , height / 2 - 300);
        option();        
    }
    public void title(int x,int y) {
        fill(0,0,0,150);
        rectMode(CENTER);
        rect(x, y, 450, 100,10);
        textAlign(CENTER,CENTER);
        myFont = createFont("標楷體",80);/* 直接輸入字型名稱，只要電腦有安裝該自行即可顯示 */
        textFont(myFont);
        fill(0);
        text("選擇學期",x-2,y-2);  
        text("選擇學期",x+2,y-2);  
        text("選擇學期",x-2,y+2);  
        text("選擇學期",x+2,y+2);  
        fill(255);
        text("選擇學期",x,y);  
    }
    public void option(){
        Arrays.stream(button).forEach(bb -> bb.render());
        return_button.render();
        for(int i=0;i<button.length;i++){
            if(button[i].isPressed()){
                chosebut=button[i].getbuttonContent();
                PageComplete = true;
                break;
            }
        }
        if(return_button.isPressed()){
            chosebut="主畫面";
            PageComplete = true;
        }
    }
}
public class College_Freshman extends College_Life{
    private Introduction intro_page = new Introduction();
    public College_Freshman(String levelname,String catname,int enemyNumber) {
        super(levelname,catname,enemyNumber);
    }
    public College_Freshman(String catname) {
        super("大一",catname,5);
        boss = new Boss(gmap,600);
    }
    public void enemy_state_render() {
        if(!intro_page.isComplete()){
            intro_page.render();
        }
        else{
            if (enemy_generate_times < enemy_number) {
                enemy_Generation(enemylist);
            }
            enemy_Render(enemylist);
            player_Render();
            for (Enemy enemy : enemylist) {
                player.bullet_shootCharater(enemy ,10);
                player.laser_shootCharater(enemy,10);
            }
        }
    }
}
public class College_Graduate extends College_Senior{
    public String[] button_3_str = {"主畫面" };
    private int boss_width = 0 ;

    PImage ntust = loadImage("pic/character/enemy/ntust.png");
    public ArrayList<Enemy> enemylist3 = new ArrayList<Enemy>();
    
    public College_Graduate(String catname) {
        super("研究所",catname,5);
        boss = new Professor(gmap,1200);
        fail_page = new Small_Window(false , "當兵",button_2_str);
        win_page = new Small_Window(true ,"畢業證書",button_3_str);
        win_page.setBackGroundImage("pic/page/" + catname + "/win (" + Level + ").jpg");
        fail_page.setBackGroundImage("pic/page/" + catname + "/lose.png");
        
    }
    public College_Graduate(String levelname,String catname,int enemyNumber) {
        super(levelname,catname,enemyNumber);
    }
    public void enemy_state_render() {
        if (enemy_generate_times < enemy_number) {
            enemy3_Generation();
        }
        enemy_Render(enemylist3);
        for (Enemy enemy3 : enemylist3) {
            player.bullet_shootCharater(enemy3 ,15);
            player.laser_shootCharater(enemy3,15);
        }
    }
    public void render() {
        background(255);
        gmap.drawBackGroundImage();
        smap.render();
        if (player.isComplete()) {  
            state = 4;
        }
        player_Render();
        switch(state) {
            case 0 : //enemy
                enemy_state_render();  
                if (enemy_dead_number == enemy_number) {
                    state = 1;
                    warning_time = millis();
                }
                break;	
            case 1 : //cutscene
                imageMode(CENTER);
                gmap.drawImage(ntust,gmap.getWidth() / 2 , gmap.getHeigh()/2,boss_width,boss_width);
                boss_width += 5;
                state = (boss_width >= 200 ) ? 2 : 1; 
                break;
            case 2 : //boss
                boss_Render();
                player.bullet_shootCharater(boss ,10);
                player.laser_shootCharater(boss,10);
                state = (boss.isComplete()) ? 5 : 2; 
                break;	
            case 3 : //pause
                pause_page.render();
                break;	
            case 4 : //failed
                fail_page.render();
                fail_page.gpa(player.hp.getLifePercentage());
                break;
            case 5 : //win
                win_page.render();
                win_page.gpa(player.hp.getLifePercentage());
                break;
        }
        option();
    }
    
    public void enemy3_Generation() {
        float distance = 0;
        float xpos = 0 , ypos = 0;
        while(distance < width / 2) {
            xpos = random(gmap.getWidth());
            ypos = random(gmap.getHeigh()); 
            float t_xpos = gmap.getX() + xpos;
            float t_ypos = gmap.getY() + ypos;
            distance = sqrt(pow((t_xpos - player.getX()),2) + pow((t_ypos - player.getY()),2));
        }
        enemylist3.add(new Enemy(new RectObject(xpos , ypos ,100,100),300,"paper"));    
        enemy_generate_times ++;
        for (Enemy enemy : enemylist3) {
            enemy.setAffect(1,2000);
        }
    }
}
public class College_Junior extends College_Life{
    
    public ArrayList<Enemy> enemylist2 = new ArrayList<Enemy>();
    
    public College_Junior(String catname) {
        super("大三",catname,10);
        boss = new Boss_Project(gmap,1000);
    }
    public College_Junior(String levelname,String catname,int enemyNumber) {
        super(levelname,catname,enemyNumber);
    }
    public void enemy_state_render() {
        if (enemy_generate_times < enemy_number) {
            enemy_Generation(enemylist);
            enemy2_Generation();
        }
        enemy_Render(enemylist);
        enemy_Render(enemylist2);
        player_Render();
        for (Enemy enemy : enemylist) {
            player.bullet_shootCharater(enemy ,15);
            player.laser_shootCharater(enemy,15);
        }
        
        for (Enemy enemy2 : enemylist2) {
            player.bullet_shootCharater(enemy2 ,15);
            player.laser_shootCharater(enemy2,15);
        }
    }

    public void enemy2_Generation() {
        float distance = 0;
        float xpos = 0 , ypos = 0;
        while(distance < width / 2) {
            xpos = random(gmap.getWidth());
            ypos = random(gmap.getHeigh()); 
            float t_xpos = gmap.getX() + xpos;
            float t_ypos = gmap.getY() + ypos;
            distance = sqrt(pow((t_xpos - player.getX()),2) + pow((t_ypos - player.getY()),2));
        }
        enemylist2.add(new Enemy(new RectObject(xpos , ypos ,100,100),"ppt"));    
        enemy_generate_times ++;
        for(Enemy enemy:enemylist2){
            enemy.setAffect(0,500);
        }
    }
}
abstract class College_Life extends page{
    public int state = 0 , pre_state;
    // public float score_point = 0;
    
    public int warning_time = 0;
    public int enemy_number;
    public int enemy_generate_times = 0;
    public int enemy_dead_number = 0;
    public String[] button_1_str = { "繼續" , "重新開始" , "主畫面" };
    public String[] button_2_str = { "重新開始" , "主畫面" };
    public String[] button_3_str = { "下一關" , "重新開始" , "主畫面" };
    public boolean CallMenu = false;
    public boolean pressed = false;
    
    public Boss boss;
    public Player player;
    public ArrayList<Enemy> enemylist = new ArrayList<Enemy>();
    public Recovering_Hp recovering;
    public Small_Map smap = new Small_Map(new RectObject(width - 200 - 50 , 50 , 200 , 150) , gmap);
    public Small_Window pause_page  , win_page , fail_page;
    
    HashMap<String,Integer> hm = new HashMap<String,Integer>();
    {
        hm.put("大一",1);
        hm.put("大二",2);
        hm.put("大三",3);
        hm.put("大四",4);
        hm.put("研究所",5);
    }
    HashMap<String,String> next_page = new HashMap<String,String>();
    {
        next_page.put("大一","大二");
        next_page.put("大二","大三");
        next_page.put("大三","大四");
        next_page.put("大四","研究所");
        next_page.put("研究所","畢業");
    }
    
    College_Life(String pagename,String catname ,int enemy_number) {
        super(pagename,catname,"pic/page/map.png");
        this.enemy_number = enemy_number;
        Level = hm.get(pagename);
        
        player = new Player(catname,gmap);
        pause_page = new Small_Window("暫停",button_1_str);
        fail_page = new Small_Window(false , "當掉",button_2_str);
        win_page = new Small_Window(true ,"歐趴",button_3_str);
        recovering = new Recovering_Hp(30);
        
        pause_page.setBackGroundImage("pic/page/" + catname + "/pause.png");
        win_page.setBackGroundImage("pic/page/" + catname + "/win (" + Level + ").jpg");
        fail_page.setBackGroundImage("pic/page/" + catname + "/lose.png");
        
    }
    public abstract void enemy_state_render();
    
    public void render() {
        background(255);
        gmap.drawBackGroundImage();
        smap.render();
        if (player.isComplete()) {  
            state = 4;
        }
        switch(state) {
            case 0 : //enemy
                enemy_state_render();  
                if (enemy_dead_number == enemy_number) {
                    state = 1;
                    warning_time = millis();
                }
                break;	
            case 1 : //cutscene
                imageMode(CENTER);
                image(warning,width / 2,height / 2,width,300);
                state = (millis() > warning_time + 3000) ? 2 : 1;
                break;
            case 2 : //boss
                boss_Render();
                player_Render();
                player.bullet_shootCharater(boss ,10);
                player.laser_shootCharater(boss,10);
                state = (boss.isComplete()) ? 5 : 2; 
                break;	
            case 3 : //pause
                pause_page.render();
                break;	
            case 4 : //failed
                fail_page.render();
                fail_page.gpa(player.hp.getLifePercentage());
                break;
            case 5 : //win
                win_page.render();
                win_page.gpa(player.hp.getLifePercentage());
                break;
        }
        option();
    }
    public void move(int moveInstr) {
        int menu = (moveInstr>>6) & 1;
        CallMenu = (menu == 1) ? true : false; 
        gmap.move(moveInstr , player);
        player.update(moveInstr);
        player.move(gmap);
    }
    public void option() {
        switch(state) {
            case 0 :      
                pre_state = 0;  
                callPausePage(3);
                break;	
            case 2:
                pre_state = 2;  
                callPausePage(3);
                break;	
            case 3 :
                if (pause_page.isComplete()) {
                    switch(pause_page.theChoseButton()) {
                        case "繼續" :
                        state = pre_state;
                        break;	
                    case "重新開始" :  
                        PageComplete = true;
                        break;	
                    case "主畫面":
                        chosebut = "主畫面";
                        PageComplete = true;
                        break;
                }
            }
            callPausePage(pre_state);
            break;	
            case 4:
                if (fail_page.isComplete()) {
                    PageComplete = true;
                    if (fail_page.theChoseButton() == "主畫面") {
                        chosebut = "主畫面";
                    }
                }
                break;
            case 5:
                LevelComplete = true;
                if (win_page.isComplete()) {
                    PageComplete = true;
                    switch(win_page.theChoseButton()) {
                        case "下一關":
                        chosebut = next_page.get(chosebut);
                        break;
                    case "主畫面":
                        chosebut = "主畫面";
                        break;
                }
            }
            break; 
        }
    }
    private void callPausePage(int next_state) {
        if (CallMenu && !pressed) {  
            pause_page.reset();
            pressed = true;  
            state = next_state;
        }
        else if (!CallMenu) {
            pressed = false;
        }
    }
    public void player_Render() {
        if (player.hp.isGone()) {
            if (player.crack(gmap)) {
                player.setComplete(true);
            }
        }
        else{
            player.render(gmap);
            player.shooting(gmap);
        }
        recovering.render(gmap,smap);
        recovering.remove(player);
        smap.small_chararcter_Render(player,0);
    } 
    
    public void enemy_Generation(ArrayList<Enemy> _enemylist) {
        float distance = 0;
        float xpos = 0 , ypos = 0;
        while(distance < width / 2) {
            xpos = random(gmap.getWidth());
            ypos = random(gmap.getHeigh()); 
            float t_xpos = gmap.getX() + xpos;
            float t_ypos = gmap.getY() + ypos;
            distance = sqrt(pow((t_xpos - player.getX()),2) + pow((t_ypos - player.getY()),2));
        }
        _enemylist.add(new Enemy(new RectObject(xpos , ypos ,100,100)));    
        enemy_generate_times ++;
    }
    
    public void enemy_Render(ArrayList<Enemy> _enemylist) {
        for (Enemy enemy : _enemylist) {
            if (enemy.hp.isGone()) {
                if (enemy.crack(gmap)) {
                    enemy.isDistroy = true;
                }
            }
            else{
                enemy.render(gmap);
                enemy.move(player);
                enemy.shooting(gmap , player);
            }
            smap.small_chararcter_Render(enemy,color(255,30,30));
        }
        enemy_Remove(_enemylist);
    }
    public void enemy_Remove(ArrayList<Enemy> _enemylist) {
        for (int i = _enemylist.size() - 1; i>= 0; i -= 1) {
            Enemy enemy = _enemylist.get(i);           
            if (enemy.isDistroy ==  true) {
                enemy_dead_number++;
                recovering.generation(enemy);
                _enemylist.remove(enemy);
            }
        }
    }
    public void boss_Render() {
        if (boss.hp.isGone()) {
            if (boss.crack(gmap)) {
                boss.setComplete(true);
            }
        }
        else{
            boss.render(gmap);
            boss.move(player);
            boss.shooting(gmap ,player);
        }
        smap.small_chararcter_Render(boss,color(255,30,30));
    }
    
    // float getLevelPoint() {
    //     return score_point;
// }
    
    private class Recovering_Hp {
        private float recover_value = 10;
        private ArrayList<PVector> coordiante = new ArrayList<PVector>();  
        public Recovering_Hp(float value) {
            recover_value = value;
        }
        public void generation(Enemy enemy) {
            coordiante.add(new PVector(enemy.getX(),enemy.getY()));
        }
        public void render(GameMap gmap,Small_Map smap) {
            for (PVector Location : coordiante) {
                float x = gmap.getWindowX(Location.x);
                float y = gmap.getWindowY(Location.y);
                noStroke();
                fill(255,0,0);
                beginShape();
                vertex(x - 20, y);
                bezierVertex(x - 20, y - 10, x + 20, y - 5, x - 20, y + 30);
                vertex(x - 20, y);
                bezierVertex(x - 20, y - 10, x - 60, y - 5, x - 20, y + 30);
                endShape();
                smap.small_object_Render(Location.x , Location.y , color(255));
            }
        }
        public void remove(Player player) {
            for (int i = coordiante.size() - 1; i>= 0; i -= 1) {
                PVector Location = coordiante.get(i);  
                if (player.distance(player.getX() , player.getY() ,Location.x,Location.y) < 50) {
                    coordiante.remove(Location);
                    player.healing(recover_value);
                }
            } 
        }
        
    }
    
    private class Small_Map{
        private float x,y,w,h;
        private float bigMapWidth , bigMapHeight;
        private PImage map = loadImage("pic/page/small_map.png");
        public Small_Map(RectObject object,GameMap gmap) {
            x = object.x;
            y = object.y;
            w = object.w;
            h = object.h; 
            bigMapWidth = gmap.getWidth();
            bigMapHeight = gmap.getHeigh();
        }
        public void render() {
            imageMode(CORNER);
            image(map ,x,y,w,h);
        }
        public void small_chararcter_Render(Character chararcter,int c_color) {
            float chararcter_x = translateX(chararcter.getX());
            float chararcter_y = translateY(chararcter.getY());
            stroke(0);
            strokeWeight(1);
            fill(c_color);
            ellipse(chararcter_x , chararcter_y , 10,10);
        }
        public void small_object_Render(float _x,float _y,int c_color) {
            float chararcter_x = translateX(_x);
            float chararcter_y = translateY(_y);
            stroke(0);
            strokeWeight(1);
            fill(c_color);
            triangle(chararcter_x, chararcter_y, chararcter_x + 10, chararcter_y + 10, chararcter_x - 10, chararcter_y + 10);
        }
        private float translateX(float _x) {
            return x + w * _x / bigMapWidth;
        }
        private float translateY(float _y) {
            return y + h * _y / bigMapHeight;
        }
    }
    
    public class Small_Window extends page{
        
        private String title_str;
        private final String butt_hovered_imgPath = "pic/button/Hover.png";
        private final String butt_pressed_imgPath = "pic/button/Pressed.png";
        
        private PFont myFont = createFont("標楷體",80);;
        private PImage backgroundImg;
        private Button[] button;
        
        Small_Window(String page,String[] button_str) {
            super(page);
            title_str = page;
            setButtonString(button_str);
        }
        Small_Window(boolean state , String page , String[] button_str) {
            super(page);
            title_str = page;
            setButtonString(button_str);
        }
        public void setBackGroundImage(String imgPath) {
            backgroundImg = loadImage(imgPath);
        }
        public void setButtonString(String[] button_str) {
            button = new Button[button_str.length];
            for (int i = 0;i < button_str.length;i++) {
                button[i] = new Button(width / 2 , height / 2 + 50 + 90 * i , 200 , 70 , button_str[i]);
                button[i].setImage(butt_hovered_imgPath , butt_pressed_imgPath);
            }
        }
        public void reset() {
            chosebut = title_str;
        }
        public void render() {
            rectMode(CORNER);
            fill(0,200);
            rect(0,0,width , height);
            imageMode(CENTER);
            image(backgroundImg , width / 2 ,height / 2 , 450,600);
            title(width / 2  , height / 2 - 250);
            option();
        }
        public void title(int _x,int _y) {
            textAlign(CENTER,CENTER);
            textFont(myFont);
            fill(0);
            text(title_str,_x - 2,_y - 2);  
            text(title_str,_x + 2,_y - 2);  
            text(title_str,_x - 2,_y + 2);  
            text(title_str,_x + 2,_y + 2);  
            fill(255);
            text(title_str,_x,_y);  
        }
        public void gpa(float score_ratio) {
            // score_point = (4.1 * score_ratio);
            String score = "D-";
            if (score_ratio > 0.9f) {
                score = "A+";
            }
            else if (score_ratio > 0.85f) {
                score = "A";
            }
            else if (score_ratio > 0.8f) {
                score = "A-";
            }
            else if (score_ratio > 0.77f) {
                score = "B+";
            }
            else if (score_ratio > 0.75f) {
                score = "B";
            }
            else if (score_ratio > 0.7f) {
                score = "B-";
            }
            else if (score_ratio > 0.6f) {
                score = "C+";
            }
            else if (score_ratio > 0.5f) {
                score = "C";
            }
            else if (score_ratio > 0.4f) {
                score = "C-";
            }
            stroke(0);
            strokeWeight(2);
            fill(255,200);
            rectMode(CENTER);
            rect(width / 2  , height / 2 - 100 , 150,150,10);
            fill(0);
            textAlign(CENTER,CENTER);
            textSize(100);
            text(score,width / 2  , height / 2 - 100);
        }
        public void option() {
            Arrays.stream(button).forEach(bb -> bb.render());
            for (int i = 0;i < button.length;i++) {
                if (button[i].isPressed()) {
                    chosebut = button[i].getbuttonContent();
                    PageComplete = true;
                    break;
                }
            }
        }
    }
}
public class College_Senior extends College_Junior{
    
    public College_Senior(String catname) {
        super("大四",catname,5);
        boss = new Reearch_Institution(gmap,1000);
        fail_page = new Small_Window(false , "大五",button_2_str);
        win_page = new Small_Window(true ,"入學許可",button_3_str);
        win_page.setBackGroundImage("pic/page/" + catname + "/win (" + Level + ").jpg");
        fail_page.setBackGroundImage("pic/page/" + catname + "/lose.png");
    }
    public College_Senior(String levelname,String catname,int enemyNumber) {
        super(levelname,catname,enemyNumber);
    }
    public void enemy_state_render() {
        if (enemy_generate_times < enemy_number) {
            enemy2_Generation();
        }
        enemy_Render(enemylist2);
        player_Render();
        for (Enemy enemy2 : enemylist2) {
            player.bullet_shootCharater(enemy2 ,15);
            player.laser_shootCharater(enemy2,15);
        }
    }
}
public class College_Sophomore extends College_Freshman{
    
    public College_Sophomore(String catname) {
        super("大二",catname,10);
        boss = new Boss_double(gmap,1000);
    }
    public void enemy_state_render() {
        if (enemy_generate_times < enemy_number) {
            enemy_Generation(enemylist);
        }
        enemy_Render(enemylist);
        player_Render();
        for (Enemy enemy : enemylist) {
            player.bullet_shootCharater(enemy ,10);
            player.laser_shootCharater(enemy,10);
        }
    }
}
class Enemy extends Character{
    public float bullet_time = 0;
    public float bullet_cd = 1000;
    public boolean isDistroy = false;
    public String imagePath = "pic/character/enemy/error.png";
    
    private PVector affect;
    public PImage error ;
    Enemy(RectObject object) {
        super(object,100);
        error = loadImage(imagePath);
        setShaking(false);
    }
    Enemy(RectObject object,float life_value, String enemyName) {
        super(object,life_value);
        imagePath = "pic/character/enemy/"+enemyName+".png";
        error = loadImage(imagePath);
        setShaking(false);
    }
    Enemy(RectObject object , String enemyName) {
        super(object,100);
        imagePath = "pic/character/enemy/"+enemyName+".png";
        error = loadImage(imagePath);
        setShaking(false);
    }
    
    public void render(GameMap gmap) {
        imageMode(CENTER);
        setMovingSpeed(5);
        gmap.drawImage(error,x,y,w,h);
        hp.render(gmap.getWindowX(x) , gmap.getWindowY(y - h / 2 - 5));
    }
    public void move(Player player) {
        distance = distance(player.getX() , player.getY() , getX() , getY());
        if (distance > player.getWidth() / 2 + 50) {
            angle = rotation(player.getX() , player.getY());
            x += cos(angle) * getMovingSpeed();
            y += sin(angle) * getMovingSpeed();
        }
    }
    public void shooting(GameMap gmap , Player player) {
        if (millis() > bullet_time + bullet_cd && distance<600) {
            bullet_time = millis();
            bulletlist.add(new Bullet(new RectObject(x,y,50,50) , angle,imagePath));
        }
        for (Bullet bullet : bulletlist) {
            bullet.setSpeed(10);
        }
        bullet_program(gmap);
        bullet_shootCharater(player , 10);
    }
    public void bullet_shootCharater(Player player,float bullet_damage) {
        for (Bullet bb : bulletlist) {
            float radians =  distance(player.getX(),player.getY(),bb.getX(),bb.getY());
            if (radians < (player.getWidth() / 2)) {
                player.isHurt(bullet_damage);
                if(affect != null ){
                    player.setAffect((int)affect.x, (int)( millis() + affect.y));
                }
                bb.isDistroy = true;
            } 
        }
        bullet_Remove(bulletlist);
    }
    public void setAffect(int type , int time){
        affect = new PVector(type , time );
    }
}
class GameMap{
    private  float wid , hei  ;
    private  float LeftSide;
    private  float RightSide;
    private  float TopSide;
    private  float BottomSide;
    
    private PImage backgroundImage;
    private int backgroundColor;
    Translate_Coordinate coordinate = new Translate_Coordinate( -50, -50);
    
    GameMap() { }
    GameMap(int backgroundColor) { 
        wid = 4000;
        hei = 3500;
        this.backgroundColor = backgroundColor;
    }
    GameMap(String mapLocation) { 
        wid = 4000;
        hei = 3500;
        backgroundImage = loadImage(mapLocation);
        Translate_Coordinate.setX( -(wid-width)/2 );
        Translate_Coordinate.setY( -(hei-height)/2 );

    }
    public void drawBackGroundImage() {
        imageMode(CORNER);
        image(backgroundImage,Translate_Coordinate.getX(),Translate_Coordinate.getY(),wid,hei);
    }
    public void fillBackGround() {
        background(backgroundColor);
    }
    public void drawImage(PImage img,float _x,float _y,float _width,float _height) {
        image(img , _x + Translate_Coordinate.getX(),_y + Translate_Coordinate.getY() , _width , _height);
    }
    public void fillrect(float _x,float _y,float _width,float _height) {
        rect(_x + Translate_Coordinate.getX() , _y + Translate_Coordinate.getY(),_width,_height);
    }
    public void fillellipse(float _x,float _y,float _width,float _height) {
        ellipse(_x + Translate_Coordinate.getX(), _y + Translate_Coordinate.getY(), _width, _height);
    }
    public void translation(float _x,float _y) {
        translate(_x + Translate_Coordinate.getX() , _y + Translate_Coordinate.getY());
    }
    public void update() {
        LeftSide = Translate_Coordinate.getX();
        RightSide = Translate_Coordinate.getX() + wid;
        TopSide = Translate_Coordinate.getY();
        BottomSide = Translate_Coordinate.getY() + hei;
    }
    public void move(int keys,Player player) {
        float speed = player.getMovingSpeed() ;
        float p_x = getWindowX(player.getX());
        float p_y = getWindowY(player.getY());

        boolean isMovingLeft = ((keys & 1) == 1) ? true : false;
        boolean isMovingRight = (((keys>>1) & 1) == 1) ? true : false;
        boolean isMovingUp = (((keys>>2) & 1) == 1) ? true : false;
        boolean isMovingDoen = (((keys>>3) & 1) == 1) ? true : false;

        if ( isMovingRight && (RightSide - speed) >= width && p_x >= width/2) { //move right
            Translate_Coordinate.setX(Translate_Coordinate.getX() - speed);
        }
        if (isMovingLeft && (LeftSide + speed) <= 0 &&  p_x <= width/2) { //move left
            Translate_Coordinate.setX(Translate_Coordinate.getX() + speed);
        } 	
        if (isMovingDoen && (BottomSide - speed) >= height && p_y >= height/2 ) { //move down
            Translate_Coordinate.setY(Translate_Coordinate.getY() - speed);
        } 	
        if (isMovingUp && (TopSide - speed) <= 0 && p_y <= height/2 ) { //move top
            Translate_Coordinate.setY(Translate_Coordinate.getY() + speed);
        }
        update();
    }
    public float getWindowX(float _x){
        return Translate_Coordinate.getX() + _x;
    }
    public float getWindowY(float _y){
        return Translate_Coordinate.getY() + _y;
    }
    public float getX(){
        return Translate_Coordinate.getX();
    }
    public float getY(){
        return Translate_Coordinate.getY();
    }
    public float getWidth(){
        return wid;
    }

    public float getHeigh(){
        return hei;
    }
}
private static class Translate_Coordinate{
    private static float xpos;
    private static float ypos;
    Translate_Coordinate(float _x,float _y) {
        xpos = _x;
        ypos = _y;
    }
    public static void setX(float x) {
        xpos = x;
    }
    public static void setY(float y) {
        ypos = y;
    }
    public static float getX() {
        return xpos;
    }
    public static float getY() {
        return ypos;
    }
}
public class Introduction extends page{
    private int state = 0;
    private boolean pressed = false;
    
    
    private PFont myFont;
    private Button next_img = new Button(width / 2 , 600 , 200, 200 / 16 * 5 , "下一頁");
    private Button complete = new Button(width / 2 , 600 , 200, 200 / 16 * 5 , "開始遊玩！");
    private PImage intro_image1 = loadImage("pic/intro/intro1.jpg");
    private PImage intro_image2 = loadImage("pic/intro/intro2.jpg");
    private PImage intro_image3 = loadImage("pic/intro/intro3.jpg");
    private PImage intro_image4 = loadImage("pic/intro/intro4.jpg");
    private PImage intro_image5 = loadImage("pic/intro/intro5.jpg");
    private PImage intro_image6 = loadImage("pic/intro/intro6.jpg");
    
    public void render() {
        float Line1 = height / 2 - 100;
        float Line2 = height / 2 + 170;
        myFont = createFont("標楷體",50);
        textFont(myFont);
        fill(0,200);
        rectMode(CORNER);
        rect(0,0,width,height);
        if (state != 5) {
            next_img.render();
        }
        else{
            complete.render();
        }
        imageMode(CENTER);
        textAlign(CENTER,CENTER);
        fill(255);
        switch(state) {
            case 0 :
                image(intro_image1 , width / 2 , Line1 , 500,400);
                text("玩家需要操控視窗的貓咪\n通過每個學期的各種挑戰",  width / 2, Line2); 
                break;	
            case 1 :
                image(intro_image2 , width / 2 , Line1 , 500,400);
                text("透過WASD能操控貓咪移動\n躲避敵人的攻擊\nESC能暫停遊戲",  width / 2, Line2); 
                break;	
            case 2 :
                image(intro_image3 , width / 2 , Line1 , 500,400);
                text("有些敵人的攻擊會附帶特殊效果\n請小心閃避",  width / 2, Line2); 
                break;	
            case 3 :
                image(intro_image4 , width / 2 , Line1 , 500,400);
                text("滑鼠左鍵能夠發射子彈",  width / 2, Line2); 
                break;	
            case 4 :
                image(intro_image5 , width / 2 , Line1 , 500,400);
                text("滑鼠右鍵能夠射出雷射",  width / 2, Line2); 
                break;	
            case 5 :
                image(intro_image6 , width / 2 , Line1 , 500,400);
                text("擊敗最終BOSS通過每個學期吧!",  width / 2, Line2); 
                break;	
        }
        option();
    }
    public void option() {
        switch(state) {
            case 5 :        
                if (complete.isPressed()) {
                    if (!pressed) {
                        PageComplete = true;
                    }
                }
                else{
                    pressed = false;
                }
                break;	
            default:
                if (next_img.isPressed()) {
                    if (!pressed) {
                        state++;
                        pressed = true;
                    }
                }
                else{
                    pressed = false;
                }
                break;
        }
    }
}
class MainPage extends page{
    private int w,h;
    private int bwidth = 300;
    private int bheigh = bwidth / 16 * 5;
    private HashMap<String,String> hm = new HashMap<String,String>();
    {
        hm.put("milk" , "牛奶");
        hm.put("pipi" , "皮皮");
        hm.put("mi" , "小咪");
    }
    private PFont myFont;
    private PImage backgroundImage ;
    private Button[] button = new Button[3];
    
    MainPage(String catname) {
        super("主畫面",catname);
        w = width;
        h = height;
        button[0] = new Button(w / 2 ,h / 2,bwidth,bheigh,"大一");
        button[1] = new Button(w / 2 ,h / 2 + bheigh + 50,bwidth,bheigh,"選擇關卡");
        button[2] = new Button(w / 2 ,h / 2 +2* bheigh + 2*50,bwidth,bheigh,"退出");
        backgroundImage = loadImage("pic/page/"+cat+"/main.jpg");
    } 
    public void render() {
        imageMode(CORNER);
        image(backgroundImage , 0 , 0,width,height);
        title(w / 2,h / 2 - 200);
        option();
    } 
    public void title(int x,int y) {
        textAlign(CENTER);
        myFont = createFont("標楷體",80);/* 直接輸入字型名稱，只要電腦有安裝該自行即可顯示 */
        textFont(myFont);
        fill(0);
        text("If "+hm.get(cat)+" study in NTUST",x-2,y-2);  
        text("If "+hm.get(cat)+" study in NTUST",x+2,y-2);  
        text("If "+hm.get(cat)+" study in NTUST",x-2,y+2);  
        text("If "+hm.get(cat)+" study in NTUST",x+2,y+2);  
        fill(255);
        text("If "+hm.get(cat)+" study in NTUST",x,y);  
    }
    public void option(){
        Arrays.stream(button).forEach(bb -> bb.render());
        for(int i=0;i<button.length;i++){
            if(button[i].isPressed()){
                chosebut=button[i].getbuttonContent();
                PageComplete = true;
                break;
            }
        }
    }       
}
class Player extends Character{

    private boolean laser_mode = false;
    
    private boolean isMovingLeft = false;
    private boolean isMovingRight = false;
    private boolean isMovingUp = false;
    private boolean isMovingDoen = false;
    private boolean bb_shoot = false;
    private boolean ll_shoot = false;
    
    private PImage left_cat ,right_cat;
    private PImage left_laser_cat,right_laser_cat;
    
    private RectObject bullet_para = new RectObject(0,1000 , 0,1);
    // bullet_time , bullet_cd , none , coffecient 
    private RectObject laser_para = new RectObject(0,5000 ,1000, 1);
    // laser_time , laser_cd , laser_duration , coffecient
    
    
    private Skill_Bar skill = new Skill_Bar();
    private Laser laser = new Laser();
    private ArrayList<PVector> affectlist = new ArrayList<PVector>();
    
    Player(String catname,GameMap gmap) {
        super(new RectObject(gmap.getWidth() / 2 , gmap.getHeigh() / 2 , 100 , 100) , 200);
        setShaking(true);
        setMovingSpeed(10);
        left_cat = loadImage("pic/character/" + catname + "/left.png");
        right_cat = loadImage("pic/character/" + catname + "/right.png");
        left_laser_cat = loadImage("pic/character/" + catname + "/laser_left.png");
        right_laser_cat = loadImage("pic/character/" + catname + "/laser_right.png");
    }
    public void render(GameMap gmap) {
        imageMode(CENTER);
        if (laser_mode) {
            gmap.drawImage((mouseX > gmap.getWindowX(x)) ? right_laser_cat : left_laser_cat , x , y , w , h);
            laser.render(gmap.getWindowX(x), gmap.getWindowY(y) ,(mouseX < gmap.getWindowX(x)));
        }
        else{
            gmap.drawImage((mouseX > gmap.getWindowX(x)) ? right_cat : left_cat , x , y , w , h);
        }
        skill.render();
        for (PVector affect : affectlist) {
            switch(PApplet.parseInt(affect.x)) {
                case 0:
                    fill(200,0,0,100);
                    gmap.fillellipse(x,y,w,h);
                    break;
                case 1:
                    fill(0,200,0,100);
                    gmap.fillellipse(x,y,w,h);
                    break;
                case 2:
                    fill(0,0,200,100);
                    gmap.fillellipse(x,y,w,h);
                    break;
            }
        }
    }
    public void update(int keys) {
        isMovingLeft = ((keys & 1) == 1) ? true : false;
        isMovingRight = (((keys>>1) & 1) == 1) ? true : false;
        isMovingUp = (((keys>>2) & 1) == 1) ? true : false;
        isMovingDoen = (((keys>>3) & 1) == 1) ? true : false;
        bb_shoot = (((keys >> 4) & 1) == 1) ? true : false;
        ll_shoot = (((keys >> 5) & 1) == 1) ? true : false;     
        removeAffect();
    }
    public void move(GameMap gmap) {       
        if (isMovingLeft && gmap.getWindowX(x) >= w / 2) {
            x -= getMovingSpeed();
        }
        if (isMovingRight &&  gmap.getWindowX(x) <= width - w / 2) {
            x += getMovingSpeed();
        }
        if (isMovingUp &&  gmap.getWindowY(y) >= h / 2) {
            y -= getMovingSpeed();
        }
        if (isMovingDoen &&  gmap.getWindowY(y) <= height - h / 2) {
            y += getMovingSpeed();
        }
    }
    
    public void shooting(GameMap gmap) {
        angle = rotation(mouseX - gmap.getX() ,mouseY - gmap.getY());
        if (bb_shoot && millis() > bullet_para.x + bullet_para.y * bullet_para.h) {
            bullet_para.x = millis();
            bulletlist.add(new Bullet(new RectObject(x,y,50,50) , angle,"pic/google.png"));
        }
        for (Bullet bullet : bulletlist) {
            bullet.setSpeed(30);
        }
        bullet_program(gmap);
        if (ll_shoot && millis() > laser_para.x + laser_para.y*laser_para.h && !laser_mode) {
            laser_para.x = millis();
            laser.reset();
            laser_mode = true;
        }
        else if (laser_mode && millis() > laser_para.x + laser_para.w) {
            laser_para.x = millis();
            laser_mode = false;
        }
    }
    
    public void laser_shootCharater(Character enemy,float laser_damage) {
        if (laser_mode) {
            float dis = distance(enemy.getX() , enemy.getY() , x  ,y);
            float enemy_angle = rotation(enemy.getX() , enemy.getY());
            float vertical_line = dis * sin(laser.getAngle() - enemy_angle);
            if (laser.isShooting() && dis < 350 && abs(laser.getAngle() - enemy_angle) < 1 /*&& vertical_line<enemy.getWidth() / 2*/) {
                enemy.isHurt(laser_damage);
            }
        }
    }
    
    public void setAffect(int type ,int time) {
        switch(type) {
            case 0 :
                affectlist.add(new PVector(type,time));
                moving.y = moving.y / 2;
                break;	
            case 1:
                affectlist.add(new PVector(type,time));
                bullet_para.h = bullet_para.h * 2;
                break;
            case 2:
                affectlist.add(new PVector(type,time));
                laser_para.h = laser_para.h * 1.5f;
                break;
        }
    }
    public void removeAffect() {
        for (int i = affectlist.size() - 1; i>= 0; i -= 1) {
            PVector affect = affectlist.get(i);           
            if (affect.y <=  millis()) {
                switch(PApplet.parseInt(affect.x)) {
                    case 0 :
                        moving.y = 1;
                        break;	
                    case 1 :
                        bullet_para.h = 1;
                        break;	
                    case 2 :
                        laser_para.h  = 1;
                        break;	
                }
                affectlist.remove(affect);
            }
        }
    }
    
    public void healing(float value) {
        hp.heal(value);
    }
    
    private class Laser{
        private int circle_width = 0;
        private int laser_beam_width = 25;
        private int laser_beam_length = 350;
        
        private int laser_state = 0;
        private float laser_angle = 0;
        private boolean Shooting = false;
        private boolean Complete = false;
        
        public void render(float x,float y,boolean left) {
            switch(laser_state) {
                case 0:
                    Complete = false;
                    Shooting = false;
                    fill(0,255,0);
                    if (circle_width % 10 > 0) {
                    }
                    else{
                        fill(255,255,255);
                    }
                    circle_width += 5;
                    ellipse(((left) ? x - 30 : x + 30),y + 50,circle_width,circle_width);
                    laser_state = (circle_width>= 50) ? 1 : 0;
                    break;
                case 1:
                    Shooting = true;
                    rectMode(CORNER);
                    noStroke();
                    fill(0,255,0);
                    laser_angle = atan2(mouseY - y, mouseX - x);
                    pushMatrix();
                    translate(x  ,y);
                    rotate(laser_angle);
                    ellipse(60,0,circle_width * 0.5f,circle_width);
                    rect(60, -laser_beam_width / 2,laser_beam_length,laser_beam_width);
                    fill(255);
                    float ratio = random(0.6f, 0.8f);
                    ellipse(60,0,circle_width * 0.5f * ratio,circle_width * ratio);
                    rect(60, -(laser_beam_width * ratio) / 2,laser_beam_length,laser_beam_width * ratio);
                    popMatrix();
                    break;
            }
        }
        public void reset() {
            laser_state = 0;
            circle_width = 0;
            Complete = true;
        }
        public float getAngle() {
            return laser_angle;
        }
        public boolean isShooting() {
            return Shooting;
        }
        // public boolean isComplete() {
        //     return Complete;
    // }
    }
    
    private class Skill_Bar{
        private float ratio;
        private int row_width = 150 ,row_height = 20;
        private PImage life_icon , bullet_icon , laser_icon;
        
        Skill_Bar() {
            life_icon = loadImage("pic/skill_icon/heart.png");
            bullet_icon = loadImage("pic/skill_icon/google_icon.png");
            laser_icon = loadImage("pic/skill_icon/ChatGPT-Logo.png");
        }
        private void render() {
            rectMode(CORNER);
            stroke(0);
            strokeWeight(1);
            fill(255);
            rect(20,20,250,150,10);
            
            imageMode(CORNER);
            image(life_icon,50,45,30,30);
            image(bullet_icon,50,80,30,30);
            image(laser_icon,50,120,30,30);
            
            strokeWeight(2);
            fill(255);
            rect(100,50,row_width,row_height,5);
            rect(100,90,row_width * 0.8f,row_height,5);
            rect(100,130,row_width * 0.8f,row_height,5);
            
            fill(255,0,0);
            rect(100,50,row_width * hp.getLifePercentage() ,row_height,5);
            
            ratio = (millis() - bullet_para.x) / bullet_para.y;
            fill((ratio >= 1) ? color(0,200,0) : 0);
            rect(100,90,row_width * 0.8f * ((ratio >= 1) ? 1 : ratio) ,row_height,5);
            
            if (laser_mode) {
                fill(color(255,255,0));
                ratio = (laser_para.x + laser_para.w - millis()) / laser_para.w;
            }
            else{
                ratio = (millis() - laser_para.x) / laser_para.y;
                fill((ratio >= 1) ? color(255,255,0) : 0);
            }
            rect(100,130,row_width * 0.8f * ((ratio >= 1) ? 1 : ratio) ,row_height,5);
        }
    }
}
/*
class UpgradePage extends page{
    private float totalscore;
    private float lastscore;
    private float spendscore;

    private PImage backgroundImage;
    private Button[] button = new Button[5];
    private Button return_button;
    UpgradePage(String catname){
        super("升級");
        backgroundImage = loadImage("pic/page/"+catname+"/choose.jpg");
        return_button = new Button(70,70,100,100," ");
        return_button.setImage(rebutt_hovered_imgPath,rebutt_pressed_imgPath);
    
    }
    void setScore(float score){
        totalscore = score ;
        lastscore = totalscore-spendscore ;
    }
    void render(){

    }
    void option(){
        if(return_button.isPressed()){
            chosebut="主畫面";
            PageComplete = true;
        }
    }
}
*/
abstract class page {
    public int Level;
    
    public String chosebut = "主畫面";
    public String cat = "pipi";
    public boolean PageComplete = false;
    public boolean LevelComplete = false;
    
    public GameMap gmap;
    
    public Cutscene cut  = new Cutscene(width / 2 ,height / 2 ,cat);
    page() {}
    page(String pagename) {
        chosebut = pagename;
    }
    page(String pagename , String catname) {
        chosebut = pagename;
        cat = catname;
        cut  = new Cutscene(width / 2 ,height / 2 ,catname);
    }
    page(String pagename, String catname,int backgroundColor) {
        chosebut = pagename;
        cat = catname;
        cut  = new Cutscene(width / 2 ,height / 2 ,catname);
        gmap = new GameMap(backgroundColor);
    }
    page(String pagename, String catname,String imgPath) {
        chosebut = pagename;
        cat = catname;
        cut  = new Cutscene(width / 2 ,height / 2 ,catname);
        gmap = new GameMap(imgPath);
    }
    
    public abstract void render();
    public void move(int moveInstr) {}
    public abstract void option();
    public String theChoseButton() {
        return chosebut;
    }
    public boolean isComplete() {
        return PageComplete;
    }
    public int getLevel() {
        return Level;
    }
    public boolean getlevelPass() {
        return LevelComplete;
    }
}

class Cutscene {
    private float left_x_1 = 0;
    private float right_x_1 = width;
    private float left_x_2 = width / 2;
    private float right_x_2 = width / 2;
    private float xpos , ypos;
    private float wid = 500 ,hei, ratio;
    private int seconds = 0;
    private boolean start = false;
    private String loading[] = {"Loading","Loading.","Loading..","Loading..."};
    
    private PImage introImg;
    Cutscene(float _x,float _y, String catname) {
        xpos = _x;
        ypos = _y;
        introImg = loadImage("pic/page/" + catname + "/cutscene.jpg");
        ratio = introImg.width / wid;
        hei = introImg.height / ratio;
    }
    public boolean startCutscene() {
        rectMode(CORNER);
        left_x_2 -= 15;
        right_x_2 += 15;
        noStroke();
        fill(42);
        rect(0,0,left_x_2,height);
        rect(right_x_2,0,width,height);
        return(left_x_2<= 0) && (right_x_2 >= width);
    }
    public boolean runCutscene() {
        if (!start) {
            seconds = millis();
            start = true;
        }
        background(42);
        imageMode(CENTER);
        image(introImg , xpos , ypos , wid , hei);
        textAlign(CENTER);
        textSize(50);
        fill(255);
        text(loading[second() % 4] , width / 2 , height - 100);
        return millis() > (seconds + 3000); 
    }
    public boolean endCutscene() {
        rectMode(CORNER);
        left_x_1 += 15;
        right_x_1 -= 15;
        noStroke();
        fill(42);
        rect(0,0,left_x_1,height);
        rect(right_x_1,0,width,height);
        
        return left_x_1>= right_x_1;
    }
}


  public void settings() { size(900, 700); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "src" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
